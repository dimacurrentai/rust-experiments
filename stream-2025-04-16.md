# Stream `2025-04-16`.

Borrowing: [link](https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=b6a03016573eb140f81827fe849bb466).

```rust
#![allow(unused_variables)]

fn main() {
    let a = String::from("foo");
    let b = a;  // Try `= &a`.
    // drop(b);
    let a = b;  // Try without `let`.
    println!("{a}");
}
```

Traits and errors: [link](https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=30935e9e0a467349461350ffa99075ba).

```rust
#![allow(unused_variables)]

use std::fmt::{Display,Formatter,Error};

#[derive(Debug)]
struct MyVec<T> {
    inner: Vec<T>
}

// Note: explain `T: Display`.

impl<T: Display + Into<i32> /* + Into<String> */> Display for MyVec<T> {
    fn fmt(&self, ostream: &mut Formatter<'_>) -> Result<(), Error> {
        // Must not have a semicolon at the end of this line!
        // write!(ostream, "MyVec Custom Printer ... of {} elements", self.inner.len())
        
        // A longer, full version. Note: explain "?;".
        write!(ostream, "MyVec Custom Printer ... of {} elements = [ ", self.inner.len())?;
        for i in &self.inner {
            write!(ostream, "{} ", i)?;  // Note: explain "?;".
        }
        write!(ostream, "]") // Note: explain the lack of semicolon.
        
        // Err(Error)
        // Ok(())  // Explain why this is important if the code is commented out.
    }
}

fn main() {
    let mut my = MyVec{ inner: Vec::new() };
    
    for i in 1..=5 {
       my.inner.push(i);
    }
    
    (6..=10).for_each(|x| my.inner.push(x));
    
    // Uses the `Debug` trait, auto-derivable.
    println!("Debug:   `{:?}`", my);
    // Uses the `fmt::Display` trait, must be user-implemented.
    println!("Display: `{}`", my);
    
    println!("Done!")
}
```

Matching: [link](https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=cd4da27c5fb79ad3405f07131d60d275).

```rust
#![allow(unused_variables)]

fn print_string(s: &Option<String>) {
    match s {
        Some(s) => println!("Some string: {s}"),
        None => println!("No string!")
    }
}

fn main() {
    // Basic matching.
    let mut maybe_string = Some("foo".to_string());
    println!("{:?}", maybe_string);
    print_string(&maybe_string);
    
    maybe_string = None;
    println!("{:?}", maybe_string);
    print_string(&maybe_string);
    
    // Matching with destructuring.
    let mut magic = (Some("foo".to_string()), Some("bar".to_string()));
    println!("{:?}", magic);
    
    // Use a closure ("lambda") as an example.
    // Note: explain need to annotate the type.
    // Note: explain can use a simple construct of `&_`, hehe.
    let print_magic = |arg: &(Option<String>, Option<String>)| {
        // println!("Arg: {:?}", &arg);
        match arg {
            (Some(s1), Some(s2)) => println!("Both: ({s1}, {s2})."),
            (None, Some(s2)) => println!("Second: (Zilch, {s2})."),
            _ => println!("Something else, too lazy to type.")
        }
    };
    print_magic(&magic);  // Note: try removing the `&`.

    magic.0 = None;
    print_magic(&magic);
    
    magic.0 = Some("hehe".to_string());
    print_magic(&magic);
}
```

Polymorphic type and `Into<T>`: [link](https://play.rust-lang.org/?version=stable&mode=debug&edition=2024&gist=70746dda53fe77e47ea1c8f68e6ef169).

```rust
struct DontPanic;

fn do_not_panic() -> DontPanic { DontPanic }

impl Into<String> for DontPanic {
    fn into(self) -> String { String::from("the answer is ...") }
}

impl Into<i32> for DontPanic {
    fn into(self) -> i32 { 42 }
}

fn print_string<T: Into<String>>(obj: T) {
    let s: String = obj.into();
    println!("string: {s}")
}

fn print_int<T: Into<i32>>(val: T) {
    let i: i32 = val.into();
    println!("int:    {i}")
}

fn main() {
    print_string(do_not_panic());
    print_int(do_not_panic());
}
```
